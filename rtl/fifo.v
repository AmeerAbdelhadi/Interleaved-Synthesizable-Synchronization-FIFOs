////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2016, University of British Columbia (UBC)  All rights reserved. //
//                                                                                //
// Redistribution  and  use  in  source   and  binary  forms,   with  or  without //
// modification,  are permitted  provided that  the following conditions are met: //
//   * Redistributions   of  source   code  must  retain   the   above  copyright //
//     notice,  this   list   of   conditions   and   the  following  disclaimer. //
//   * Redistributions  in  binary  form  must  reproduce  the  above   copyright //
//     notice, this  list  of  conditions  and the  following  disclaimer in  the //
//     documentation and/or  other  materials  provided  with  the  distribution. //
//   * Neither the name of the University of British Columbia (UBC) nor the names //
//     of   its   contributors  may  be  used  to  endorse  or   promote products //
//     derived from  this  software without  specific  prior  written permission. //
//                                                                                //
// THIS  SOFTWARE IS  PROVIDED  BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" //
// AND  ANY EXPRESS  OR IMPLIED WARRANTIES,  INCLUDING,  BUT NOT LIMITED TO,  THE //
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE //
// DISCLAIMED.  IN NO  EVENT SHALL University of British Columbia (UBC) BE LIABLE //
// FOR ANY DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY, OR CONSEQUENTIAL //
// DAMAGES  (INCLUDING,  BUT NOT LIMITED TO,  PROCUREMENT OF  SUBSTITUTE GOODS OR //
// SERVICES;  LOSS OF USE,  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION) HOWEVER //
// CAUSED AND ON ANY THEORY OF LIABILITY,  WHETHER IN CONTRACT, STRICT LIABILITY, //
// OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE //
// OF  THIS SOFTWARE,  EVEN  IF  ADVISED  OF  THE  POSSIBILITY  OF  SUCH  DAMAGE. //
////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////
//               fifo.v: interleaved FIFO for clock-domain crossing               //
//             Author: Ameer Abdelhadi (ameer.abdelhadi@gmail.com)                //
// Cell-based interleaved FIFO :: The University of British Columbia :: Nov. 2016 //
////////////////////////////////////////////////////////////////////////////////////

// include config file; generated by scr/do; defines DATAWD, VERSTG, HORSTG & SYNCDP
`include "config.h"

module fifo
  #( parameter           NV = `VERSTG,  // number of vertical fifo stages
     parameter           NH = `HORSTG,  // number of horizontal fifo stages
     parameter           DW = `DATAWD,  // data width
     parameter           SD = `SYNCDP)  // brute-force synchronizer depth
   ( input               rst         ,  // global reset 
     input               clk_put     ,  // clocked sender  : clock for sender domain
     input               req_put     ,  // clocked sender  : request put
     output reg          spaceav     ,  // clocked sender  : space available indicator
     input  [DW-1:0]     datain      ,  // clocked sender  : data in
     input               clk_get     ,  // clocked receiver: clock for receiver domain
     input               req_get     ,  // clocked receiver: request get
     output reg          datav       ,  // clocked receiver: data valid indicator
     output     [DW-1:0] dataout     ); // clocked receiver: data out

  // general indices
  integer v,h,i,j,k,s;
  // indices for generate blocks
  genvar gh,gv;

  reg req_put_l;
  always@(clk_put, req_put)
    if (!clk_put) req_put_l <= req_put;
  
  reg spaceav_l;
  always@(clk_put, spaceav)
    if (!clk_put) spaceav_l <= spaceav;

  wire do_put_x = req_put_l && spaceav_l;

  reg do_put;
  always@(clk_put, do_put_x)
    if(clk_put) do_put <= do_put_x;

  wire req_put_safe = req_put && spaceav;
  
  reg  req_put_safe_l;
  always@(clk_put, req_put_safe)
    if(!clk_put) req_put_safe_l <= req_put_safe;

  // thermometer vectors: token rings
  reg  [NV-1:0] thVS;
  reg  [NH-1:0] thHS;
  reg  [NV-1:0] thVR;
  reg  [NH-1:0] thHR; 
  reg           mvH;
  wire [NV-1:0] thVS_next =  do_put ? {thVS[(NV-2):0], !thVS[NV-1]} : thVS;
  wire [NH-1:0] thHS_next =  mvH    ? {thHS[(NH-2):0], !thHS[NH-1]} : thHS;

  always@(posedge clk_put, posedge rst)
    if (rst) mvH <= 1'b0;
    else mvH <= (req_put && spaceav) && (thVS_next[NV-1] ^ thVS_next[NV-2]);

  always@(posedge clk_put, posedge rst)
    if(rst) thVS <= {NV{1'b0}};
    else thVS <= thVS_next;

  always@(posedge clk_put, posedge rst)
    if(rst) thHS <= {NV{1'b0}};
    else thHS <= thHS_next;

  always@(posedge clk_get, posedge rst)
    if (rst) thVR <= {NV{1'b0}};
    else if (req_get) thVR <= {thVR[NV-2:0],!thVR[NV-1]};

  always@(posedge clk_get, posedge rst)
    if (rst) thHR <= {NH{1'b0}};
    else if (req_get && (thVR[NV-1] ^ thVR[NV-2])) thHR <= {thHR[NH-2:0],!thHR[NH-1]};

  // thermometer matrices
  reg [NV-1:0] thS [NH-1:0];
  reg [NV-1:0] thR [NH-1:0];
  always @*
    for (h=0;h<NH;h=h+1)
      for (v=0;v<NV;v=v+1) begin
        thS[h][v] = ( ((h==0) ? !thHS[NH-1] : thHS[h-1]) && (h[0] ^ thVS[v]) ) || ( thHS[h] && (h[0] ~^ thVS[v]) );
        thR[h][v] = ( ((h==0) ? !thHR[NH-1] : thHR[h-1]) && (h[0] ^ thVR[v]) ) || ( thHR[h] && (h[0] ~^ thVR[v]) );
      end

  // onehot vectors
  reg [NV-1:0] ohVS;
  reg [NV-1:0] ohVS_p;
  reg [NH-1:0] ohHS;
  reg [NH-1:0] ohHS_p;
  reg [NV-1:0] ohVR;
  reg [NH-1:0] ohHR;
  always @* begin
    for (v=0;v<NV;v=v+1) ohVS[v]   = ((v==0) ? !thVS[NV-1]      : thVS[v-1]     ) ^ thVS[v];
    for (v=0;v<NV;v=v+1) ohVS_p[v] = ((v==0) ? !thVS_next[NV-1] : thVS_next[v-1]) ^ thVS_next[v];
    for (v=0;v<NV;v=v+1) ohVR[v]   = ((v==0) ? !thVR[NV-1]      : thVR[v-1]     ) ^ thVR[v];
    for (h=0;h<NH;h=h+1) ohHS[h]   = ((h==0) ? !thHS[NH-1]      : thHS[h-1]     ) ^ thHS[h];
    for (h=0;h<NH;h=h+1) ohHS_p[h] = ((h==0) ? !thHS_next[NH-1] : thHS_next[h-1]) ^ thHS_next[h];
    for (h=0;h<NH;h=h+1) ohHR[h]   = ((h==0) ? !thHR[NH-1]      : thHR[h-1]     ) ^ thHR[h];
  end

  // correspond to what ohHS and ohVS will be after the next clk_put+.
  reg [NV-1:0] ohVS_l;
  reg [NH-1:0] ohHS_l;
  always@(clk_put, ohVS_p)
    if (!clk_put) ohVS_l <= {NV{req_put_safe}} & ohVS_p;
  always@(clk_put, ohHS_p)
    if (!clk_put) ohHS_l <= ohHS_p;

  // sender one-hot counter
  reg [NH*NV-1:0] ohR;
  always @* for (h=0;h<NH;h=h+1) for (v=0;v<NV;v=v+1) ohR[h*NV+v] = ohHR[h] && ohVR[v];

  // full matrix
  reg [NV-1:0] fll [NH-1:0];
  always @* for (h=0;h<NH;h=h+1) for (v=0;v<NV;v=v+1) fll[h][v] = thS[h][v] ^ thR[h][v];

  // vertical full/empty (for each line)
  reg [NV-1:0] fllV;
  reg [NV-1:0] empV;
  reg [NV-1:0] fllVa;
  reg [NV-1:0] empVa;
  reg [NV-1:0] fllVb;
  reg [NV-1:0] empVb;
  always @*
    for (v=0;v<NV;v=v+1) begin
      fllVa[v] = 1'b0;
      empVa[v] = 1'b0;
      fllVb[v] = 1'b0;
      empVb[v] = 1'b0;
      for (h=0;h<NH;h=h+1) begin
        fllVa[v] = fllVa[v] ||   fll[h][v];
        empVa[v] = empVa[v] ||  !fll[h][v];
        fllVb[v] = fllVb[v] || ( fll[h][v] && !ohHR[h]);
        empVb[v] = empVb[v] || (!fll[h][v] && !ohHS[h]);
      end
      fllV[v] = (!(req_get && ohVR[v]) && fllVa[v]) || fllVb[v];
      empV[v] = (!(do_put && ohVS[v]) && empVa[v]) || empVb[v];
    end

  // write synchronizers: synchronize write occurance to get domain
  reg [SD-1:0] fllV_sync [NV-1:0];
  reg [SD-1:0] empV_sync [NV-1:0];
  always@(posedge clk_get, posedge rst)
    if (rst) for (v=0;v<NV;v=v+1)
      fllV_sync[v] <= {SD{1'b0}};
    else for (v=0;v<NV;v=v+1)
      fllV_sync[v] <= {((req_get   && ohVR[v]) ? {(SD-1){1'b0}} : fllV_sync[v][SD-2:0]),fllV[v]};
  always@(posedge clk_put, posedge rst)
    if (rst) for (v=0;v<NV;v=v+1)
      empV_sync[v] <= {SD{1'b0}};
    else for (v=0;v<NV;v=v+1)
      empV_sync[v] <= {((do_put && ohVS[v]) ? {(SD-1){1'b0}} : empV_sync[v][SD-2:0]),empV[v]};

  // put all the empVS ... spaceav logic in one place followed by the fullVS ... datav logic.
  reg [NV-1:0] empVS;
  always @* for (v=0;v<NV;v=v+1) empVS[v] = empV_sync[v][SD-1];
  wire [NV-1:0] empVS_ror = {empVS[0],empVS[NV-1:1]};
  wire spaceav_p = (|empVS)&&(!req_put_l) ||  (|(empVS & empVS_ror));
  always@(posedge clk_put, posedge rst) if (rst) spaceav <= 1'b0; else spaceav <= spaceav_p;

  // now calculate datav_p.  Use separate "odd"/"even" approach.
  reg [(NV/2)-1:0] fllVR_even;
  always @* for (v=0;v<NV/2;v=v+1) fllVR_even[v] = fllV_sync[2*v][SD-1];
  wire dv_even = |fllVR_even;
  reg [(NV/2)-1:0] fllVR_odd;
  always @* for (v=0;v<NV/2;v=v+1) fllVR_odd[v] = fllV_sync[2*v+1][SD-1];
  wire dv_odd = |fllVR_odd;
  wire datav_p = (dv_even || dv_odd)&&(!req_get) || (dv_even && dv_odd);
  always@(posedge clk_get, posedge rst) if (rst) datav   <= 1'b0; else datav   <= datav_p ;
  // The odd/even interleaving for datav_p applies directly to dataout_p.

  reg [DW-1:0] datain_l;
  always@(clk_put, datain)
    if (!clk_put) datain_l <= datain;

  // latch enables
  reg [NV-1:0] latch_enb [NH-1:0];
  always @*
    for (v=0;v<NV;v=v+1)
      for (h=0;h<NH;h=h+1)
        latch_enb[h][v] = clk_put && ohHS_l[h] && ohVS_l[v];

  // latch input data in the active stage (with write indicator)
  reg [DW-1:0] data_storage [NH-1:0][NV-1:0];
  generate
    for (gh=0;gh<NH;gh=gh+1) begin:ltcH
      for (gv=0;gv<NV;gv=gv+1) begin:ltcV
         always@(latch_enb[gh][gv], datain_l)
           if (latch_enb[gh][gv]) data_storage[gh][gv] <= datain_l;
       end
     end
  endgenerate

   // storage words as 1d vector with tri-states
   tri [DW-1:0] dataoutZ [NH*NV-1:0];
   generate
     for (gh=0;gh<NH;gh=gh+1) begin:triH
       for (gv=0;gv<NV;gv=gv+1) begin:triV
         assign dataoutZ[gh*NV+gv] = (ohR[gh*NV+gv]||ohR[((gh+gv)==0)?(NH*NV-1):(gh*NV+gv-1)]) ? data_storage[gh][gv] : {DW{1'bz}};
       end
     end
   endgenerate

  // even stages grouped together for interleaving
  wire [DW-1:0] dataout_even_p;
   genvar gi;
   generate
     for (gi=0;gi<(NV*NH);gi=gi+2) begin:evn
       assign dataout_even_p = dataoutZ[gi];
     end
   endgenerate

  // odd stages grouped together for interleaving
  wire [DW-1:0] dataout_odd_p;
   generate
     for (gi=1;gi<(NV*NH);gi=gi+2) begin:odd
       assign dataout_odd_p = dataoutZ[gi];
     end
   endgenerate

  // a selector for even/odd stages; toggles if get is enabled
  reg  dataout_sel;
  wire dataout_sel_p = dataout_sel ^ req_get;
  always@(posedge clk_get, posedge rst)
    if (rst) dataout_sel<= 1'b0;
    else     dataout_sel<= dataout_sel_p;

  reg sel_even;
  always@(posedge clk_get, posedge rst)
    if (rst) sel_even <= 1'b0;
    else     sel_even <= dv_even && !dataout_sel_p;

  reg sel_odd;
  always@(posedge clk_get, posedge rst)
    if (rst) sel_odd <= 1'b0;
    else     sel_odd <= dv_odd && dataout_sel_p;

  // select odd/even output data based on output selector
  // if neither is valid, output all 0's.
  reg [DW-1:0] dataout_even;
  always@(posedge clk_get) dataout_even <= dataout_even_p;
  reg [DW-1:0] dataout_odd;
  always@(posedge clk_get) dataout_odd <= dataout_odd_p;

  assign dataout = (dataout_even & {DW{sel_even}}) | (dataout_odd & {DW{sel_odd}});

endmodule // clkd2clkd_fifo

